<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Google KickStart Round B 2020</title>
    <link href="/2020/05/12/Google-KickStart-Round-B-2020/"/>
    <url>/2020/05/12/Google-KickStart-Round-B-2020/</url>
    
    <content type="html"><![CDATA[<p>犹记得4.19我打开kickstart，豪情满怀全副武装地准备第二天的比赛，结果无语地发现比赛已经结束了。记错日期really hurts。一个月后（5.12）才把B轮做了，一开始无比顺利，甚至不知道是这次比赛变水了还是我变强了（喂？），直到第4题教我做人……</p><p>我算着时间进行的模拟比赛，大概1h10min做完前三道题，1h35min通过了第4题的小数据。然后就一直失败地尝试。小小算了一下排名，大概能600+/9000+吧，虽然也没很好，至少在进步啦。</p><h1 id="Bike-Tour"><a href="#Bike-Tour" class="headerlink" title="Bike Tour"></a>Bike Tour</h1><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>小李骑车跨越瑞士群山，他的旅程有<code>n</code>站，问有多少个峰值站。<br>翻译：寻找数组<code>h</code>的极大值的个数。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>签到题目，一次遍历，寻找比相邻两个点都大的数。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度：<code>O(n)</code>，<code>n</code>为数组长度。<br>空间复杂度：<code>O(1)</code></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    n = int(input())    h = [int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)]    res = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>):        <span class="hljs-keyword">if</span> h[i] &gt; h[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> h[i] &gt; h[i + <span class="hljs-number">1</span>]:            res += <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, res))</code></pre><h1 id="Bus-Routes"><a href="#Bus-Routes" class="headerlink" title="Bus Routes"></a>Bus Routes</h1><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>小桶同学在票圈看到在瑞士骑车的小李po出的美照，心生羡慕，也计划了一次长途旅行。她需要依次做<code>n</code>列巴士，每个巴士<code>i</code>都有特定的属性<code>X[i]</code>，该巴士只在第<code>X[i]</code>、<code>X[i] * 2</code>… 天发车。小桶每天可以乘坐任意次巴士。小桶希望在第<code>D</code>天之前到达目的地，问她最晚的出发日期是多少。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>继续送分。这里是用的O（n）的方法，倒叙遍历。先看小桶坐最后一列巴士的最晚日期，如此迭代，直到计算到坐第一列巴士的最晚日期。</p><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度：<code>O(n)</code>，一次遍历。<br>空间复杂度：<code>O(1)</code>。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    n, d = map(int, input().split(<span class="hljs-string">' '</span>))    bus = [int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):        d = d // bus[i] * bus[i]    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, d))</code></pre><h4 id="赛后：二分法"><a href="#赛后：二分法" class="headerlink" title="赛后：二分法"></a>赛后：二分法</h4><p>比赛结束后，在油管看了两个大神(Scott Wu和William Lin)的录屏，他们都一眼看出是二分题，可能这就是竞赛选手吧。二分的时间复杂度是<code>O(N log(D))</code>。如果聪明的你想到缩小二分的起始右边界，那么时间复杂度可以优化到<code>O(N log(D/X1))</code>。</p><h1 id="Robot-Path-Encoding"><a href="#Robot-Path-Encoding" class="headerlink" title="Robot Path Encoding"></a>Robot Path Encoding</h1><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>超级太空机器人降落新的星球上，这个星球是$10 ^ 9 × 10 ^ 9$的格子。机器人从位置<code>(1,1)</code>开始，按照你输入的指令移动。指令的语法是这样的：<code>N, S, E, W</code>表示向四个方向移动一位，同时指令允许批量和嵌套。如<code>3(S2(E))</code> 等同于<code>SEESEESEE</code>。此外，这个星球是圆的（…），所以注意取模。</p><h4 id="思路：栈"><a href="#思路：栈" class="headerlink" title="思路：栈"></a>思路：栈</h4><p>看到括号后，第一反应就是，这不就是表达式运算嘛。于是果断写起了栈。<br>有两个地方我思考比较久：<br>一是数据结构的设计，最终我决定用两个栈，<code>s_stack</code>存字符，<code>l_stack</code>存位置的二元列表。每次应该处理偏移量时，就用<code>*</code>在<code>s_stack</code>中占位，同时把偏移量存到<code>l_stack</code>中。<br>二是遇到”<code>)</code>后pop的过程。一定会先pop所有的偏移量，再pop出数字，这个是确定的。我一开始想成偏移量和数字会交替出现了。<br>Anyway，写了长达50min，还好提交一次过啦。</p><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度：<code>O(n)</code>，<code>n</code>为指令长度。一次遍历。<br>空间复杂度：<code>O(n)</code>，<code>n</code>为指令长度。两个栈的长度都不会超过<code>n</code>。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    s = input()    border = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>    col, row = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>    s_stack = []    l_stack = []    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> i != len(s):        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">'N'</span>:            l_stack.append([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>])            s_stack.append(<span class="hljs-string">'*'</span>)        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'S'</span>:            l_stack.append([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])            s_stack.append(<span class="hljs-string">'*'</span>)        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'W'</span>:            l_stack.append([<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>])            s_stack.append(<span class="hljs-string">'*'</span>)        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'E'</span>:            l_stack.append([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])            s_stack.append(<span class="hljs-string">'*'</span>)        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">')'</span>:            curr = s_stack.pop()            dx, dy = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> curr != <span class="hljs-string">'('</span>:                step = l_stack.pop()                dx += step[<span class="hljs-number">0</span>]                dy += step[<span class="hljs-number">1</span>]                curr = s_stack.pop()            d = s_stack.pop()            <span class="hljs-keyword">while</span> s_stack <span class="hljs-keyword">and</span> <span class="hljs-string">'1'</span> &lt;= s_stack[<span class="hljs-number">-1</span>]  &lt;= <span class="hljs-string">'9'</span>:                  curr = s_stack.pop()                  d = curr + d            <span class="hljs-comment"># print(int(d))</span>            dx *= int(d)            dy *= int(d)            l_stack.append([dx % border, dy % border])            s_stack.append(<span class="hljs-string">'*'</span>)        <span class="hljs-keyword">else</span>:            s_stack.append(s[i])        i += <span class="hljs-number">1</span>    <span class="hljs-comment">#     print(s_stack)</span>    <span class="hljs-comment">#     print(l_stack)</span>    row, col = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> len(l_stack):        step = l_stack.pop()        row += step[<span class="hljs-number">0</span>]        col += step[<span class="hljs-number">1</span>]    row = row % border + <span class="hljs-number">1</span>    col = col % border + <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125; &#123;&#125;'</span>.format(c, col, row))</code></pre><h4 id="赛后：递归解法"><a href="#赛后：递归解法" class="headerlink" title="赛后：递归解法"></a>赛后：递归解法</h4><p>递归方法无论是从思路到写法都简便很多，时间复杂度也为<code>O(n)</code>。这里提供两种写法。<br>一个是我的方法，每遇到<strong>数字</strong>，就把<strong>匹配括号对</strong>内的子串重新送入dfs，指针<code>i</code>跳到<code>)</code>后面。比如输入是<code>E4(W3(S))NN</code>，遇到4之后，去递归子串<code>W3(S)</code>，<code>i</code>指向<code>N</code>。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s)</span>:</span>    i = <span class="hljs-number">0</span>    dx, dy = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> i != len(s):        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">'N'</span>:            dx -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'S'</span>:            dx += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'W'</span>:            dy -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'E'</span>:            dy += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> <span class="hljs-string">'0'</span> &lt;= s[i] &lt;= <span class="hljs-string">'9'</span>:            d = <span class="hljs-string">''</span>            <span class="hljs-keyword">while</span> s[i] != <span class="hljs-string">'('</span>:                d += s[i]                i += <span class="hljs-number">1</span>            d = int(d)            j = i + <span class="hljs-number">1</span>            n = <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> n != <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> s[j] == <span class="hljs-string">')'</span>:                    n -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> s[j] == <span class="hljs-string">'('</span>:                    n += <span class="hljs-number">1</span>                j += <span class="hljs-number">1</span>            step = dfs(s[i:j])            dx += step[<span class="hljs-number">0</span>] * d  % border            dy += step[<span class="hljs-number">1</span>] * d  % border            i = j - <span class="hljs-number">1</span>        i += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> dx % border , dy % bordert = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    s = input()    border = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>    row, col = dfs(s)    row = row % border + <span class="hljs-number">1</span>    col = col % border + <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125; &#123;&#125;'</span>.format(c, col, row))</code></pre><p>另一个是看william lin的视频学到的，竞赛选手真的好喜欢用全局变量。把<code>i</code>定义为全局变量，instead of遇到数字时递归，这里采用的方法是遇到<code>)</code>就return。简便之处就是无需判断匹配括号了。第一次见这种写法，还挺神奇的。<br>btw，最好每次移动<code>dx</code>和<code>dy</code>都判断一下越没越界。但python选手就先不care了。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s)</span>:</span>    <span class="hljs-keyword">global</span> i    dx, dy = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> i &lt; len(s):        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">'N'</span>:            dx -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'S'</span>:            dx += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'W'</span>:            dy -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">'E'</span>:            dy += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">')'</span>:            <span class="hljs-keyword">return</span> dx, dy        <span class="hljs-keyword">elif</span> <span class="hljs-string">'0'</span> &lt;= s[i] &lt;= <span class="hljs-string">'9'</span>:            d = <span class="hljs-string">''</span>            <span class="hljs-keyword">while</span> s[i] != <span class="hljs-string">'('</span>:                d += s[i]                i += <span class="hljs-number">1</span>            i += <span class="hljs-number">1</span>            d = int(d)            step = dfs(s)            dx += step[<span class="hljs-number">0</span>] * d            dy += step[<span class="hljs-number">1</span>] * d        i += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> dx % border , dy % bordert = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    s = input()    i = <span class="hljs-number">0</span>    border = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span>    row, col = dfs(s)    row = row % border + <span class="hljs-number">1</span>    col = col % border + <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125; &#123;&#125;'</span>.format(c, col, row))</code></pre><h1 id="Wandering-Robot"><a href="#Wandering-Robot" class="headerlink" title="Wandering Robot"></a>Wandering Robot</h1><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>有一片<code>h</code>行<code>w</code>列的场地，机器人要从左上角移动到右下角。场地中间的某块矩形区域是雷区，如果走到雷区，它就game over了。雷区位置已知，左上角在<code>(L, U)</code>，右下角在<code>(R, D)</code>。已知机器人每步等概率向右走和向下走。问机器人能顺利通过挑战的概率。</p><h4 id="机器人我不知道，我自己通关概率好渺小"><a href="#机器人我不知道，我自己通关概率好渺小" class="headerlink" title="机器人我不知道，我自己通关概率好渺小"></a>机器人我不知道，我自己通关概率好渺小</h4><p>我一上来感觉挺简单的，递推关系显而易见。<br>设<code>dp[i][j]</code>为从位置<code>(i, j)</code>出发能通关的概率。<br>如果<code>(i, j)</code>在雷区，通关无望，<code>dp[i][j]</code>为0。<br>如果<code>(i, j)</code>在最下一行或者在最右一列，那么这时只能选择一个方向，分别有<code>dp[i][j] = dp[i][j + 1]</code>和<code>dp[i][j] = dp[i + 1][j]</code><br>其他情况下，有递推方程：<br>$$dp[i][j] = 0.5 × dp[i][j + 1] + 0.5 × dp[i + 1][j]$$<br>我想着如果写dp的话需要从后向前遍历，为了写起来方便，我使用了dfs+记忆化搜索。<br>我提交之后，静静等待结果，天真地幻想着：该不会这场我carry了吧。<br>然鹅现实如此残酷，大数据MLE辽。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(i, j, w, h, l, u, r, d, dp)</span>:</span>    <span class="hljs-keyword">if</span> i == h <span class="hljs-keyword">and</span> j == w:        dp[i][j] = <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> dp[i][j]    <span class="hljs-keyword">if</span> l &lt;= j &lt;= r <span class="hljs-keyword">and</span> u &lt;= i &lt;= d:        dp[i][j] = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> dp[i][j]    <span class="hljs-keyword">if</span> dp[i][j] != <span class="hljs-number">-1</span>:        <span class="hljs-keyword">return</span> dp[i][j]    <span class="hljs-keyword">if</span> j == w:        dp[i][j] = dfs(i + <span class="hljs-number">1</span>, j, w, h, l, u, r, d, dp)        <span class="hljs-keyword">return</span> dp[i][j]    <span class="hljs-keyword">if</span> i == h:        dp[i][j] = dfs(i, j + <span class="hljs-number">1</span>, w, h, l, u, r, d, dp)        <span class="hljs-keyword">return</span> dp[i][j]    dp[i][j] = <span class="hljs-number">0.5</span> * dfs(i + <span class="hljs-number">1</span>, j, w, h, l, u, r, d, dp) + <span class="hljs-number">0.5</span> * dfs(i, j + <span class="hljs-number">1</span>, w, h, l, u, r, d, dp)    <span class="hljs-keyword">return</span> dp[i][j]t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    w, h, l, u, r, d = map(int, input().split(<span class="hljs-string">' '</span>))    dp = [[<span class="hljs-number">-1</span>] * (w + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(h + <span class="hljs-number">1</span>)]    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, w, h, l, u, r, d, dp)    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]))</code></pre><p>好的，其实我的比赛就到这里告终了，但我依旧开始无尽的尝试。我想着还是用dp+滚动数组吧，内存就不会超了，虽然<code>w*h = 10^10</code>的复杂度是超时的，但我偏要勉强（？）。提交之后，果然TLE呢。</p><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    w, h, l, u, r, d = map(int, input().split(<span class="hljs-string">' '</span>))    dp = [<span class="hljs-number">1</span>] * (w + <span class="hljs-number">1</span>)    <span class="hljs-comment"># init last row</span>    <span class="hljs-keyword">if</span> d == h:        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, r + <span class="hljs-number">1</span>):            dp[j] = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(h - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):        <span class="hljs-comment"># dp[i][w] = 0 if hole else dp[i + 1][w]</span>        <span class="hljs-keyword">if</span> l &lt;= w &lt;= r <span class="hljs-keyword">and</span> u &lt;= i &lt;= d:            dp[w] = <span class="hljs-number">0</span>        <span class="hljs-comment"># dp[i][j] = 0 if hole else 0.5*dp[i][j+1]+0.5*dp[i+1][j]</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(w - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">if</span> l &lt;= j &lt;= r <span class="hljs-keyword">and</span> u &lt;= i &lt;= d:                dp[j] = <span class="hljs-number">0</span>            <span class="hljs-keyword">else</span>:                dp[j] = <span class="hljs-number">0.5</span> * dp[j] + <span class="hljs-number">0.5</span> * dp[j + <span class="hljs-number">1</span>]    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, dp[<span class="hljs-number">1</span>]))</code></pre><h4 id="hin接近了"><a href="#hin接近了" class="headerlink" title="hin接近了"></a>hin接近了</h4><p>时间复杂度必须降到O（n）才可以呀。其实我看到这题就想到了<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a>，那道题insightful的点在于把问题转化为了组合数。这题也一样，<code>落入hole某点的概率 = sigma(到该点的路径的概率)</code>。而且，我们需要看的只是hole的上边和左边，其他地方是不可能接触到的，于是时间复杂度是线性的。<br>想法不复杂，一写就出错，细节实在太难搞了，我在IDE里各种debug。直到de到我造了好多例子都跟前面的算法的答案一致，corner case也都测了，我想着应该ok了，可是提交就WA了。继续de，但我怎么造例子答案都是对的。三个小时的计时也结束辽，so模拟比赛就完结了。还是po一下代码，不知道哪里不对。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m, n)</span>:</span>    <span class="hljs-comment"># corner case</span>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">1</span>):        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> (m &gt; n):        m, n = n, m    temp = <span class="hljs-number">1</span>    res = <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m):        temp *= i    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n, m + n - <span class="hljs-number">1</span>):        res *= i    <span class="hljs-keyword">return</span> int(res / temp)t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    w, h, l, u, r, d = map(int, input().split(<span class="hljs-string">' '</span>))    <span class="hljs-keyword">if</span> l == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> r == w <span class="hljs-keyword">or</span> u == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> d == h:        print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, <span class="hljs-number">0</span>))        <span class="hljs-keyword">continue</span>    res = <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> l == w:        p = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, u + <span class="hljs-number">1</span>):            res += (uniquePaths(i, l) - p) * <span class="hljs-number">2</span> ** (-(w - <span class="hljs-number">2</span> + i))            p += uniquePaths(i, l)    <span class="hljs-keyword">elif</span> u == h:        p = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, l + <span class="hljs-number">1</span>):            res += (uniquePaths(i, u) - p) * <span class="hljs-number">2</span> ** (-(h - <span class="hljs-number">2</span> + i))            p += uniquePaths(i, u)    <span class="hljs-keyword">else</span>:        res += uniquePaths(u, l) * <span class="hljs-number">2</span> ** (-(u + l - <span class="hljs-number">2</span>))    <span class="hljs-keyword">if</span> u != <span class="hljs-number">1</span>:        <span class="hljs-comment"># col in [l + 1, r - 1]</span>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(l + <span class="hljs-number">1</span>, r):            res += uniquePaths(u - <span class="hljs-number">1</span>, col) * <span class="hljs-number">2</span> ** (-(u + col - <span class="hljs-number">2</span>))        <span class="hljs-comment"># col == r</span>        <span class="hljs-keyword">if</span> r != l <span class="hljs-keyword">and</span> r != w:            res += uniquePaths(u - <span class="hljs-number">1</span>, r) * <span class="hljs-number">2</span> ** (-(u + r - <span class="hljs-number">2</span>))        <span class="hljs-keyword">elif</span> r != l <span class="hljs-keyword">and</span> r == w:            p = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, u):                res += (uniquePaths(i, l) - p) * <span class="hljs-number">2</span> ** (-(w - <span class="hljs-number">2</span> + i))                p += uniquePaths(i, l)    <span class="hljs-keyword">if</span> l != <span class="hljs-number">1</span>:        <span class="hljs-comment"># row in [u + 1, d - 1]</span>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(u + <span class="hljs-number">1</span>, d):            res += uniquePaths(row, l - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> ** (-(l + row - <span class="hljs-number">2</span>))        <span class="hljs-comment"># row in [d]</span>        <span class="hljs-keyword">if</span> u != d <span class="hljs-keyword">and</span> d != h:            res += uniquePaths(d, l - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> ** (-(l + d - <span class="hljs-number">2</span>))        <span class="hljs-keyword">elif</span> u != d <span class="hljs-keyword">and</span> d == h:            p = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, l):                res += (uniquePaths(i, u) - p) * <span class="hljs-number">2</span> ** (-(h - <span class="hljs-number">2</span> + i))                p += uniquePaths(i, u)    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, <span class="hljs-number">1</span> - res))</code></pre><h4 id="写不正确的正确答案"><a href="#写不正确的正确答案" class="headerlink" title="写不正确的正确答案"></a>写不正确的正确答案</h4><p>官方题解太巧妙了，跟我上面的思路如出一辙，但是简单很多。解法就不细说了。<br>我按照这个思路重写了代码，也使用了log运算防止数值溢出，但是一提交还是WA。跟我上面的代码一样，我自己怎么测都对，但提交不过诶。Anyway，时间这么宝贵，下次kickstart见！</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> mathMAXN = <span class="hljs-number">1000000</span>lfac = [<span class="hljs-number">0</span>] * MAXN<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(lfac)):    lfac[i] = lfac[i - <span class="hljs-number">1</span>] + math.log(i, <span class="hljs-number">2</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prob</span><span class="hljs-params">(m, n)</span>:</span>    <span class="hljs-comment"># corner case</span>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">1</span>):        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> ** (-(m + n - <span class="hljs-number">2</span>))    res = lfac[m + n - <span class="hljs-number">2</span>] - lfac[m - <span class="hljs-number">1</span>] - lfac[n - <span class="hljs-number">1</span>] - (m + n - <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> ** rest = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    w, h, l, u, r, d = map(int, input().split(<span class="hljs-string">" "</span>))    res = <span class="hljs-number">0</span>    i = d + <span class="hljs-number">1</span>    j = l - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> i &lt;= h <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">1</span>:        res += prob(i, j)        i += <span class="hljs-number">1</span>        j -= <span class="hljs-number">1</span>    i = u - <span class="hljs-number">1</span>    j = r + <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j &lt;= w:        res += prob(i, j)        i -= <span class="hljs-number">1</span>        j += <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, res))</code></pre><h1 id="总结：对比赛的深入剖析"><a href="#总结：对比赛的深入剖析" class="headerlink" title="总结：对比赛的深入剖析"></a>总结：对比赛的深入剖析</h1><p>一言以蔽之，这场比赛=两个出门旅行的同学+两个出门散步的机器人+一个半年没出门的我。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kickstart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google KickStart Round A 2020</title>
    <link href="/2020/05/12/Google-KickStart-Round-A-2020/"/>
    <url>/2020/05/12/Google-KickStart-Round-A-2020/</url>
    
    <content type="html"><![CDATA[<p>比赛是在2020/03/22，人生第一次kickstart，当时leetcode都没过百题就上了，菜并兴奋着。只做出来两道半，排名也不是很高。时隔两个月再回顾当时的提交记录，只想感叹我当初如此勇敢无畏，什么都不会，什么都敢写，而且拿<code>submit</code>当做<code>test</code>来用…</p><h1 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h1><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有<code>n</code>个房子，每个价格为<code>A[i]</code>，而你有<code>B</code>刀，问可买几套。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>秒。用贪心的思想，每次买最便宜的，直到买不起为止。<br>算法分两步：首先排序，然后一次遍历，直到余额不足以支付当前的房子。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度<code>O(nlog(n))</code>，<code>n</code>为房子数量。<br>空间复杂度<code>O(1)。</code></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    num, money = map(int, input().split(<span class="hljs-string">" "</span>))    res = <span class="hljs-number">0</span>    prices = sorted([int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)])    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(num):        <span class="hljs-keyword">if</span> money - prices[j] &gt;= <span class="hljs-number">0</span>:            money -= prices[j]            res += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">break</span>    print(<span class="hljs-string">"Case #&#123;&#125;: &#123;&#125;"</span>.format(i, res))</code></pre><h1 id="Plates"><a href="#Plates" class="headerlink" title="Plates"></a>Plates</h1><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>有<code>N</code>堆盘子，每堆有<code>k</code>个。每个盘子有自己的价值。小P想拿走<code>p</code>个盘子，注意，每堆拿走的盘子一定是最上面的那些。问拿走的盘子的价值是多少。<br>翻译：给定数组<code>values[n][k]</code>和正数<code>p</code>，需要数组中选择<code>p</code>项。选择的规则是：如果选择<code>values[i][j]</code>，那么一定要选择<code>values[i][0:j-1]</code>。求最大和。</p><h4 id="naive的心路历程"><a href="#naive的心路历程" class="headerlink" title="naive的心路历程"></a>naive的心路历程</h4><p>不得不吐槽一下，我第一反应是贪心法，用<code>n</code>个指针指向<code>n</code>个堆，每次选择值最大的，移动该堆的指针。而且我错误地做法遭遇了TLE，于是我一往无前地继续优化orz，改用heap来做，类似于合并k个链表。就是建立最大堆，每次pop出指最大的盘子。终于我WA了，清醒一点才发现这种贪心的思想并行不通。我在这道题折腾了很久，直到万念俱灰万籁俱寂，无奈之下暴力过了小数据量。</p><h4 id="回看"><a href="#回看" class="headerlink" title="回看"></a>回看</h4><p>啊，如此明显的dp！我感受到了我飞速的进步。首先求<code>values</code>的前缀和数组，然后二维dp。不过挺容易写错的，加一减一什么的。最后决定将<code>suf</code>数组和<code>dp</code>数组都补一圈0，这样两者之间依旧是对齐的，写起来方便一点。</p><h4 id="dp推导"><a href="#dp推导" class="headerlink" title="dp推导"></a>dp推导</h4><p><code>dp[i][j]</code>表示在前<code>i</code>堆（从1开始）的盘子拿出<code>j</code>个（从1开始）的最大值。我们可以选择在第<code>i</code>堆拿走<code>m∈[0, j]</code>个盘子，拥有的价值为<code>suf[i][j]</code>。我们还需要从前<code>i-1</code>堆拿走<code>p-j</code>个盘子，也就是再加上<code>dp[i-1][j-m]</code>的价值。注意，<code>m</code>不能超过第<code>i</code>堆盘子的总个数，所以准确来说，<code>m ∈ [0, min(j, k)]</code>。</p><pre><code class="hljs markdown">for i [1, N]: for j [1, P]:  dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] := 0   for m [0, min(j, K)]:    dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] = max(dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>], dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-m</span>]+suf[<span class="hljs-string">i</span>][<span class="hljs-symbol">m</span>])</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：<code>O(nkp)</code>，三重循环。<br>空间复杂度：<code>O(np)</code>，<code>dp</code>数组的大小。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs python">t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>):    n, k, p = map(int, input().split(<span class="hljs-string">" "</span>))    values = []    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):        values.append([int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)])    <span class="hljs-comment"># suffix</span>    suf = [[<span class="hljs-number">0</span>] * (k + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n + <span class="hljs-number">1</span>)]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>):            suf[i][j] = suf[i][j - <span class="hljs-number">1</span>] + values[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]    <span class="hljs-comment"># dp</span>    dp = [[<span class="hljs-number">0</span>] * (p + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n + <span class="hljs-number">1</span>)]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, p + <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(min(j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>)):                dp[i][j] = max(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - m] + suf[i][m])    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, dp[n][p]))</code></pre><h1 id="Workout"><a href="#Workout" class="headerlink" title="Workout"></a>Workout</h1><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>小T准备上<code>n</code>节健身课，每节课为<code>M[i]</code>分钟，<code>M</code>是严格递增的。她可以在其中再插入<code>k</code>节课，时长自选。健身项目的难度定义为相邻课的时长差的最大值。问小T能设计出的最低难度是多少。</p><h4 id="非正规解法"><a href="#非正规解法" class="headerlink" title="非正规解法"></a>非正规解法</h4><p>我当时又角度清奇。我是这么想的，举个栗子，比如<code>sessions</code>为<code>[10 13 15 16 17]</code>，能补两次。先算出差值矩阵<code>init</code>为<code>[3, 2, 1, 1]</code>，待除矩阵<code>div = [1, 1, 1, 1]</code>，两者pixelwise除一下，得到难度矩阵<code>diff = [3, 2, 1, 1]</code>。我们每次找<code>diff</code>中最大的，然后将它对应的<code>div</code>+1，算出新的<code>diff</code>。我们插入一次课，有<code>div = [2, 1, 1, 1]</code>，<code>diff = [2, 2, 1, 1]</code>。再插入一次（选择哪个2为最大值不重要），有<code>div = [3, 1, 1, 1]</code>，<code>diff = [1, 2, 1, 1]</code>，答案就是<code>max(diff) = 2</code>。<br>经检验，这个思路是正确的，不过时间复杂度是<code>O(kn)</code>，TLE警告。所以我选择用heap优化，降到了O(klog(n)) = O(1e5 log(1e5))。耶最终AC了。（赛前我做了heap的专题，所以真的很喜欢朝着heap靠orz</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> ceil<span class="hljs-keyword">import</span> heapqt = int(input())<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t+<span class="hljs-number">1</span>):    n, k = map(int, input().split(<span class="hljs-string">" "</span>))    sessions = [int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)]    diff = []    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):        diff.append(sessions[j]-sessions[j<span class="hljs-number">-1</span>])    diff_div_init = [(-elem, <span class="hljs-number">1</span>, elem) <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> diff]    heapq.heapify(diff_div_init)    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>):        k -= <span class="hljs-number">1</span>        currdiff, currdiv, init = heapq.heappop(diff_div_init)        heapq.heappush(diff_div_init, (-ceil((init) / (currdiv + <span class="hljs-number">1</span>)), currdiv + <span class="hljs-number">1</span>, init))    currdiff, currdiv, ind = heapq.heappop(diff_div_init)    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(i, -currdiff))</code></pre><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>时光荏苒，岁月如梭。通过这俩月的学习，我一眼就能看出这题是很典型的“对值的二分”，好励志。我们的目标是寻找最小的最大差值<code>d</code>，who还能满足切分次数<code>k&#39; &lt;= k</code>。<code>d</code>初始化的区间为<code>[1, max_diff]</code>，在这个区间内二分即可。时间复杂度为<code>O(nlog(max_diff)) = O(nlog(m)) = O(1e5 log(1e9))</code>。</p><p>相似题目推荐：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/zui-xiao-dui-er-fen-fa-pythonjava-by-coldme-2/" target="_blank" rel="noopener">378. 有序矩阵中第K小的元素</a>、<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/dui-zhi-de-er-fen-fa-by-coldme-2/" target="_blank" rel="noopener">410. 分割数组的最大值</a>。刷过几道同类题后，手感就来了。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid</span><span class="hljs-params">(sess, mid, k)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(sess)):        diff = sess[i] - sess[i - <span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> diff &gt; mid:            <span class="hljs-comment"># notice here, also can be written as</span>            <span class="hljs-comment"># k -= ceil(diff / mid) - 1</span>            k -= (diff - <span class="hljs-number">1</span>) // mid            <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t+<span class="hljs-number">1</span>):    n, k = map(int, input().split(<span class="hljs-string">" "</span>))    sess = [int(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> input().split(<span class="hljs-string">" "</span>)]    low, high = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):        high = max(high, sess[i] - sess[i - <span class="hljs-number">1</span>])    <span class="hljs-keyword">while</span> low &lt; high:        mid = low + (high - low) // <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> valid(sess, mid, k):            high = mid        <span class="hljs-keyword">else</span>:            low = mid + <span class="hljs-number">1</span>    print(<span class="hljs-string">'Case #&#123;&#125;: &#123;&#125;'</span>.format(c, low))</code></pre><h1 id="Bundling"><a href="#Bundling" class="headerlink" title="Bundling"></a>Bundling</h1><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>有<code>n</code>个字符串，对它们进行分组，每组<code>k</code>个字符串，保证可均分。每组的分数是组内所有字符串的最长公共前缀的长度，求总分数。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>当时也知道是前缀树，但不知道下一步该怎么求。现在想想，依旧没想到：)。参考了<a href="https://blog.csdn.net/sinat_32682001/article/details/105109492" target="_blank" rel="noopener">这里的解题思路</a>，才想明白的。记每个前缀字符被共享的次数为$count$，那么这个字符的最大贡献为$$\lfloor \frac{cnt}{k} \rfloor$$，所以总分数为：<br>$$\Sigma_i \lfloor \frac{cnt_i}{k} \rfloor$$<br>另外，Trie的<code>add</code>函数如果使用递归，会超时，所以改用了迭代。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.cnt = <span class="hljs-number">0</span>        self.children = [<span class="hljs-literal">None</span>] * <span class="hljs-number">26</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, s)</span>:</span>        self.cnt += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:            <span class="hljs-keyword">return</span>        ch = s[<span class="hljs-number">0</span>]        i = ord(ch) - ord(<span class="hljs-string">'A'</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.children[i]:            self.children[i] = TrieNode()        self.children[i].add(s[<span class="hljs-number">1</span>:])t = int(input())<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, t+<span class="hljs-number">1</span>):    n, k = map(int, input().split())    ss = []    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n):        ss.append(input())    <span class="hljs-comment"># Build Trie Tree</span>    root = TrieNode()    base = ord(<span class="hljs-string">'A'</span>)    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> ss:        t = root        <span class="hljs-comment"># use iterative way instead of recursively</span>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:            t.cnt += <span class="hljs-number">1</span>            i = ord(ch) - base            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> t.children[i]:                t.children[i] = TrieNode()            t = t.children[i]        t.cnt += <span class="hljs-number">1</span>    <span class="hljs-comment"># Traverse the tree</span>    res = <span class="hljs-number">0</span>    stack = [root]    root.cnt = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> len(stack):        curr = stack.pop()        res += curr.cnt // k        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> curr.children:            <span class="hljs-keyword">if</span> child <span class="hljs-keyword">and</span> child.cnt &gt;= k:                stack.append(child)    print(<span class="hljs-string">'Case #%d: %d'</span> % (c, res))</code></pre><h1 id="总结：论比赛的正确打开方式"><a href="#总结：论比赛的正确打开方式" class="headerlink" title="总结：论比赛的正确打开方式"></a>总结：论比赛的正确打开方式</h1><p>在油管follow了william，看他打比赛真是我日常消遣。19min拿下了Round A，respect！<br>虽然自己做题很艰辛，但是看别人做题轻松呀（聪明！</p>]]></content>
    
    
    
    <tags>
      
      <tag>kickstart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/2020/03/04/My-New-Post/"/>
    <url>/2020/03/04/My-New-Post/</url>
    
    <content type="html"><![CDATA[<p>C’est la vie! </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/02/hello-world/"/>
    <url>/2020/03/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
